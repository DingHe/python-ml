《python学习手册》
第21章：模块雄伟蓝图 
模块及模块包是代码重用的最高层级 
Python把载入的模块存储到一个名为sys.modules的表中 
import sys
print sys.modules
导入的最后是执行程序的代码，如果模块文件中的任何顶层代码确实做了什么工作，就是在导入时看到其结果

模块搜索路径：
1.程序的主目录
2.PYTHONPATH目录
3.标准链接库目录
4.任何.pth文件的内容 
这四个就组成了sys.path
import sys
print sys.path

distutils工具安装软件，一般都附带setup.py脚本

第22章：模块代码的编写基础
模块创建：
使用文本编辑器，把一些Python代码输入至文本文件中，然后以".py"为后缀名进行保存
模块名在PYTHON程序中会变成变量名，因此应该遵循第11章所提到的普通变量名的命名规则

模块使用：
import modules1        #必须通过模块名称来引用模块属性，import将整个模块对象赋值给一个变量名
from module1 import printer   #直接引用某个属性 ，可以直接使用变量名称，from将一个或者多个变量赋值给另一个模块中同名的对象
from moudle1 import *    #导入module1全部的属性
导入模块只会执行一次 

模块命名空间：
模块的命名空间能通过属性__dict__和dir(M)获取
在模块文件中赋值的变量名，在内部成为字典的键，python也会在模块的名称空间内加入一些变量名，例如__file_指明模块从哪个文件加载，__name__指明导入者的名称

重载模块：
reload(module)

第23章：模块包
Python代码的目录就称为包，包导入就是把计算机上的目录变成另一个Python命名空间，而属性则对应于目录中所包含的子目录和模块文件
包导入语句的路径中的每个目录内必须有__init__.py这个文件，__init__.py可以包含Python程序代码。
Python首次导入某个目录时，会自动执行该目录下的__init__.py文件中的所有程序代码
可以在__init__.py文件内使用__all__列表来定义目录以 from * 语句形式导入时，需要导出什么


第24章：高级模块话题
最小化from *的破坏：_X和__all__
把下划线放在变量名前面（例如_X）,可以防止客户端使用from * 语句导入模块名时，把其中的哪些变量复制过去。
可以在模块顶层把变量名的字符串列表赋值给变量__all__，以达到类似于_X命名惯例的隐藏效果，例如：
__all__=["Error","encode","decode"]
启动以后的语言特性：
from __future__ import featurename
混合用法模式：
如果文件是以顶层程序文件执行，在启动时，__name__就会设置为字符串“__main__”
如果文件被导入，__name__就会改设成客户端所了解的模块名

第25章：oop宏伟蓝图
Python把隐含的实例传进方法中的第一个特殊的参数，习惯上将其称为self
Python中class语句中的小括号内有一个以上的超类，他们由左至右的次序会决定超类搜索的顺序

第26章：类代码编写基础
在方法内对self属性做赋值运算会产生每个实例自己的属性，在类方法函数内，第一个参数（按惯例称为self）会引用正处理的梳理对象，
对self的属性做赋值运算，会创建或者修改实例内的数据，而不是类的数据
在类嵌套的代码块中顶层的赋值的任何变量都会变成类的属性，注意类的属性和实例属性的区别
在方法函数中，调用时，第一个参数自动接收隐含的实例对象：调用的主体。
在Python中，实例从类继承，而类继承于超类
在Python中通用惯例指出，类名应该以一个大写字母开头
运算符重载就是让用类写成的对象，可截获并相应在内置类型上的运算：加法、切片、打印和点号运算等：
1.以双下划线命名的方法（__X__）是特殊钩子
2.当实例出现在内置运算时，这类方法会自动调用

世界上最简单的类：
class rec:pass

第27章：更多实例

















































